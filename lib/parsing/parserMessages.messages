term_parser: ID ARROW RPAREN
##
## Ends in an error in state: 41.
##
## term -> fact ARROW . term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## fact ARROW
##

After an `$0` (arrow), a term is expected.
For example:
> $1 $0 Type

term_parser: ID RPAREN
##
## Ends in an error in state: 126.
##
## term_parser -> top . EOF [ # ]
## top -> top . COLON term [ EOF COLON ]
##
## The known suffix of the stack is as follows:
## top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##

I'm currently parsing a term.
After `$0`, the end of file is expected.

term_parser: KWD_FORALL LPAREN ID COLON ID RPAREN COMMA RPAREN
##
## Ends in an error in state: 37.
##
## term -> KWD_FORALL nonempty_list(arg) COMMA . term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_FORALL nonempty_list(arg) COMMA
##

I'm currently parsing a pi type.
After the `,` (comma), the body of the pi type is expected.
For example:
> $2 $1 $0 Type

term_parser: KWD_FORALL LPAREN ID COLON ID RPAREN BIG_ARROW
##
## Ends in an error in state: 36.
##
## term -> KWD_FORALL nonempty_list(arg) . COMMA term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_FORALL nonempty_list(arg)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 45, spurious reduction of production nonempty_list(arg) -> arg
##

I'm currently parsing a pi type.
After the list of arguments, a `,` (comma) is expected followed by the body of the product type.
For example:
> $1 $0 , <term>



term_parser: KWD_FORALL RPAREN
##
## Ends in an error in state: 35.
##
## term -> KWD_FORALL . nonempty_list(arg) COMMA term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_FORALL
##

I'm currently parsing the arguments of a pi type.
After the `$0`, an argument of the form `(id ... id : term)` is expected.
For example:
> $0 (a b : Type), ...
> $0, ...

term_parser: KWD_LAMBDA LPAREN ID COLON ID KWD_LET
##
## Ends in an error in state: 75.
##
## arg -> LPAREN nonempty_list(id) COLON term . RPAREN [ LPAREN COMMA COLON BIG_ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN nonempty_list(id) COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
##

I'm currently parsing arguments to a pi type or lambda expression.
After the `$0`, a closing parenthesis is expected `)`.

term_parser: KWD_LAMBDA LPAREN ID COLON ID RPAREN BIG_ARROW VERNAC_VARIANT_S
##
## Ends in an error in state: 34.
##
## term -> KWD_LAMBDA nonempty_list(arg) BIG_ARROW . term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LAMBDA nonempty_list(arg) BIG_ARROW
##

I'm currently parsing the body of a lambda expression.
After `=>` (big arrow), a term is expected.
For example:
> $2 $1 $0 Type

term_parser: KWD_LAMBDA LPAREN ID COLON ID RPAREN RPAREN
##
## Ends in an error in state: 45.
##
## nonempty_list(arg) -> arg . [ COMMA BIG_ARROW ]
## nonempty_list(arg) -> arg . nonempty_list(arg) [ COMMA BIG_ARROW ]
##
## The known suffix of the stack is as follows:
## arg
##

I'm currently parsing the arguments of a lambda expression.
I expect more arguments of the form `(id ... id : type)` or a `=>` (big arrow) followed
by the body of the lambda.
For example:
> $0, ...
> $0 (id1 id2 : Type), ...

term_parser: KWD_LAMBDA LPAREN ID COLON RPAREN
##
## Ends in an error in state: 17.
##
## arg -> LPAREN nonempty_list(id) COLON . term RPAREN [ LPAREN COMMA COLON BIG_ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN nonempty_list(id) COLON
##

I'm currently parsing the type of the arguments of a lambda expression.
After the `:` (colon), a term is expected.
For example:
> $2 $1 $0 Type), ...

term_parser: KWD_LAMBDA LPAREN ID RPAREN
##
## Ends in an error in state: 77.
##
## nonempty_list(id) -> id . [ COLON ]
## nonempty_list(id) -> id . nonempty_list(id) [ COLON ]
##
## The known suffix of the stack is as follows:
## id
##

I'm currently parsing the arguments of a lambda expression.
I expect more identifiers or a colon followed by a type.
For example:
> $0 foo bar : ?0)
> $0 : ?0)

term_parser: KWD_LAMBDA LPAREN RPAREN
##
## Ends in an error in state: 15.
##
## arg -> LPAREN . nonempty_list(id) COLON term RPAREN [ LPAREN COMMA COLON BIG_ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

I'm currently parsing the arguments of a lambda expression.
I expect a nonempty list of identifiers.
For example:
> (x : ?0), ...
> (x y z : ?0), ...
> (x : ?0) (y z : Type), ...

term_parser: KWD_LAMBDA RPAREN
##
## Ends in an error in state: 32.
##
## term -> KWD_LAMBDA . nonempty_list(arg) BIG_ARROW term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LAMBDA
##

I'm currently parsing the arguments of a lambda expression.
I expect a nonempty list of arguments of the form `(id ... id : type)`.
For example:
> $0 (x : a)
> $0 (x y z : a)

term_parser: KWD_LET RPAREN
##
## Ends in an error in state: 29.
##
## term -> KWD_LET . id COLON term ASSIGN term KWD_IN term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LET
##

I'm currently parsing the binder of a let expression.
After the `let`, an identifier is expected followed by `:`.
For example:
> $0 x : ?0 := <term>
> $0 f : foo Type ?1 := <term>

term_parser: KWD_LET ID RPAREN
##
## Ends in an error in state: 30.
##
## term -> KWD_LET id . COLON term ASSIGN term KWD_IN term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LET id
##

I'm currently parsing a let expression.
After the identifier, a `:` (colon) is expected followed by a type.
For example:
> $1 $0 : ?0 := <term>
> $1 $0 : foo Type ?1 := <term>

term_parser: KWD_LET ID COLON RPAREN
##
## Ends in an error in state: 31.
##
## term -> KWD_LET id COLON . term ASSIGN term KWD_IN term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON
##

I'm currently parsing the binder's type of a let expression.
After the `:`, an expression is expected followed by `:=`.
For example:
> $2 $1 $0 ?0 := <term>
> $2 $1 $0 foo Type ?1 := <term>

term_parser: KWD_LET ID COLON ID RPAREN
##
## Ends in an error in state: 48.
##
## term -> KWD_LET id COLON term . ASSIGN term KWD_IN term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
##

I'm currently parsing the bounded term's type of a let expression.
After the `:`, an expression is expected followed by `:=`.
For example:
> $3 $2 $1 $0 := <term>
> $3 $2 $1 $0 x := <term>

term_parser: KWD_LET ID COLON ID ASSIGN VERNAC_VARIANT_S
##
## Ends in an error in state: 49.
##
## term -> KWD_LET id COLON term ASSIGN . term KWD_IN term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON term ASSIGN
##

I'm currently parsing the bounded term of a let expression.
After the `:=`, an expression is expected followed by `in`.
For example:
> $4 $3 $2 $1 $0 Type in <term>

term_parser: KWD_LET ID COLON ID ASSIGN ID VERNAC_SEPARATOR
##
## Ends in an error in state: 50.
##
## term -> KWD_LET id COLON term ASSIGN term . KWD_IN term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON term ASSIGN term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
##

Missing `in` keyword, in let expression.

term_parser: KWD_LET ID COLON ID ASSIGN ID KWD_IN VERNAC_VARIANT_S
##
## Ends in an error in state: 51.
##
## term -> KWD_LET id COLON term ASSIGN term KWD_IN . term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LET id COLON term ASSIGN term KWD_IN
##

I'm currently parsing the body of a let expression.
After the `in`, an expression is expected.
For example:
> $6 $5 $4 $3 $2 $1 $0 Type

term_parser: KWD_UNKNOWN RPAREN
##
## Ends in an error in state: 21.
##
## atom -> KWD_UNKNOWN . INT [ VERNAC_SEPARATOR VBAR RPAREN LPAREN KWD_WITH KWD_UNKNOWN_T KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_END KWD_AS ID EOF COLON ASSIGN ARROW ]
##
## The known suffix of the stack is as follows:
## KWD_UNKNOWN
##

I'm currently parsing the universe level of an unknown term.
After the `$0`, a non-negative integer is expected.
For example:
> $0 0
> ?1

term_parser: KWD_UNKNOWN_T RPAREN
##
## Ends in an error in state: 19.
##
## atom -> KWD_UNKNOWN_T . INT [ VERNAC_SEPARATOR VBAR RPAREN LPAREN KWD_WITH KWD_UNKNOWN_T KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_END KWD_AS ID EOF COLON ASSIGN ARROW ]
##
## The known suffix of the stack is as follows:
## KWD_UNKNOWN_T
##

I'm currently parsing the universe level of the unknown type.
After the `$0`, a non-negative integer is expected.
For example:
> $0 0
> !1

term_parser: LPAREN RPAREN
##
## Ends in an error in state: 18.
##
## atom -> LPAREN . top RPAREN [ VERNAC_SEPARATOR VBAR RPAREN LPAREN KWD_WITH KWD_UNKNOWN_T KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_END KWD_AS ID EOF COLON ASSIGN ARROW ]
##
## The known suffix of the stack is as follows:
## LPAREN
##

I'm currently parsing a parenthesised term.
After the `(` a term is expected followed by a closing parenthesis `)`.
For example:
> (f x y)
> (foo ?0 y)
> (fun (x : Type) => x)

term_parser: RPAREN
##
## Ends in an error in state: 125.
##
## term_parser' -> . term_parser [ # ]
##
## The known suffix of the stack is as follows:
##
##

I'm currently parsing a term.
At the top level, a term is expected.
For example:
> let f : ?0 := Type in f
> fun (x : Type) => x

program_parser: RPAREN
##
## Ends in an error in state: 119.
##
## program_parser' -> . program_parser [ # ]
##
## The known suffix of the stack is as follows:
##
##

I'm currently parsing a program.
At the top level, a command is expected.
For example:
> Eval let f : ?0 := Type in f.
> Check (fun (x : Type) => x).


program_parser: VERNAC_EVAL VERNAC_SEPARATOR
##
## Ends in an error in state: 93.
##
## command -> VERNAC_EVAL . top [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_EVAL
##

A term is expected after the `$0` command.
For example:
> $0 let f : ?0 := Type in f.


term_parser: KWD_LAMBDA LPAREN ID COLON ID RPAREN COMMA
##
## Ends in an error in state: 33.
##
## term -> KWD_LAMBDA nonempty_list(arg) . BIG_ARROW term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_LAMBDA nonempty_list(arg)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 45, spurious reduction of production nonempty_list(arg) -> arg
##

I'm currently parsing the arguments of a lambda expression.
I expect more arguments of the form (x y z : t) or a `=>` (big arrow) followed
by the body of the lambda.
For example:
> $1 $0 => ...
> $1 $0 (id1 id2 : Type) => ...


program_parser: VERNAC_ELABORATE VERNAC_SEPARATOR
##
## Ends in an error in state: 95.
##
## command -> VERNAC_ELABORATE . top [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_ELABORATE
##

A term is expected after the `$0` command.
For example:
> $0 let f : ?0 := Type in f.

program_parser: VERNAC_CHECK VERNAC_SEPARATOR
##
## Ends in an error in state: 104.
##
## command -> VERNAC_CHECK . top [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_CHECK
##

A term is expected after the `$0` command.
For example:
> $0 Type : Type@1.

program_parser: VERNAC_ELABORATE ID VERNAC_SEPARATOR VERNAC_SEPARATOR
##
## Ends in an error in state: 120.
##
## list(sequenced_command) -> sequenced_command . list(sequenced_command) [ EOF ]
##
## The known suffix of the stack is as follows:
## sequenced_command
##

After `$0`, another command or the EOF are expected.

program_parser: VERNAC_SET VERNAC_VARIANT_S
##
## Ends in an error in state: 1.
##
## command -> VERNAC_SET . flag [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_SET
##

The command `$0` should be followed by a configuration option.
For example:
> $0 Variant G.
> $0 Fuel 0.


term_parser: LPAREN ID VERNAC_SEPARATOR
##
## Ends in an error in state: 73.
##
## atom -> LPAREN top . RPAREN [ VERNAC_SEPARATOR VBAR RPAREN LPAREN KWD_WITH KWD_UNKNOWN_T KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_END KWD_AS ID EOF COLON ASSIGN ARROW ]
## top -> top . COLON term [ RPAREN COLON ]
##
## The known suffix of the stack is as follows:
## LPAREN top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##

Missing `)` after $0, to close the parenthesised term.

term_parser: ID COLON VERNAC_VARIANT_S
##
## Ends in an error in state: 64.
##
## top -> top COLON . term [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_END KWD_AS EOF COLON ]
##
## The known suffix of the stack is as follows:
## top COLON
##

I'm currently parsing an ascription.
After the `:` (colon), a term is expected.
For example:
> $1 $0 <SOME TYPE>

program_parser: VERNAC_CHECK ID RPAREN
##
## Ends in an error in state: 105.
##
## command -> VERNAC_CHECK top . [ VERNAC_SEPARATOR ]
## top -> top . COLON term [ VERNAC_SEPARATOR COLON ]
##
## The known suffix of the stack is as follows:
## VERNAC_CHECK top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##
program_parser: VERNAC_ELABORATE ID VERNAC_VARIANT_S
##
## Ends in an error in state: 96.
##
## command -> VERNAC_ELABORATE top . [ VERNAC_SEPARATOR ]
## top -> top . COLON term [ VERNAC_SEPARATOR COLON ]
##
## The known suffix of the stack is as follows:
## VERNAC_ELABORATE top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##
program_parser: VERNAC_EVAL ID VERNAC_VARIANT_S
##
## Ends in an error in state: 94.
##
## command -> VERNAC_EVAL top . [ VERNAC_SEPARATOR ]
## top -> top . COLON term [ VERNAC_SEPARATOR COLON ]
##
## The known suffix of the stack is as follows:
## VERNAC_EVAL top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##

Missing a `.` after $0, to close the command. 
For example:
> $1 $0.


program_parser: VERNAC_DEFINITION VERNAC_VARIANT_S
##
## Ends in an error in state: 97.
##
## command -> VERNAC_DEFINITION . id list(arg) COLON term ASSIGN top [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_DEFINITION
##

An identifier must come after `$0`.
For example:
> $0 my_function_name (x : Type) : Type@1 := x.

program_parser: VERNAC_DEFINITION ID VERNAC_VARIANT_S
##
## Ends in an error in state: 98.
##
## command -> VERNAC_DEFINITION id . list(arg) COLON term ASSIGN top [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_DEFINITION id
##

I expect arguments of the form `(id ... id : type)` or a `:` (colon) followed
by the type of the definition.
For example:
> $1 $0 (a b : Type) : Type@1 := <body>.
> $1 $0 : Type@1 := <body>.

command_parser: VERNAC_DEFINITION ID LPAREN ID COLON ID RPAREN VERNAC_VARIANT_S
##
## Ends in an error in state: 88.
##
## list(arg) -> arg . list(arg) [ COLON ]
##
## The known suffix of the stack is as follows:
## arg
##

I expect arguments of the form `(id ... id : type)` or a `:` (colon) followed
by the type of the definition.
For example:
> $0 (a b : Type) : Type@1 := <body>.
> $0 : Type@1 := <body>.


program_parser: VERNAC_DEFINITION ID COLON VERNAC_VARIANT_S
##
## Ends in an error in state: 100.
##
## command -> VERNAC_DEFINITION id list(arg) COLON . term ASSIGN top [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_DEFINITION id list(arg) COLON
##

The type of the definition must follow the `:` (colon).
For example:
> $3 $2 $1 $0 Type@1 := <body>.

program_parser: VERNAC_DEFINITION ID COLON ID VERNAC_VARIANT_S
##
## Ends in an error in state: 101.
##
## command -> VERNAC_DEFINITION id list(arg) COLON term . ASSIGN top [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_DEFINITION id list(arg) COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
##

I expect an `:=` (assign) followed by the body of the definition.
For example:
> $4 $3 $2 $1 $0 := <body>.

command_parser: VERNAC_DEFINITION ID COLON ID ASSIGN VERNAC_VARIANT_S
##
## Ends in an error in state: 102.
##
## command -> VERNAC_DEFINITION id list(arg) COLON term ASSIGN . top [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_DEFINITION id list(arg) COLON term ASSIGN
##

The body of the definition must follow the `:=` (assign).
For example:
> $5 $4 $3 $2 $1 $0 Type.

command_parser: VERNAC_DEFINITION ID COLON ID ASSIGN ID VBAR
##
## Ends in an error in state: 103.
##
## command -> VERNAC_DEFINITION id list(arg) COLON term ASSIGN top . [ VERNAC_SEPARATOR ]
## top -> top . COLON term [ VERNAC_SEPARATOR COLON ]
##
## The known suffix of the stack is as follows:
## VERNAC_DEFINITION id list(arg) COLON term ASSIGN top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##

Missing a `.`, to close the definition. 
For example:
> ... $1 $0.

program_parser: VERNAC_LOAD VERNAC_VARIANT_S
##
## Ends in an error in state: 10.
##
## command -> VERNAC_LOAD . FILENAME [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_LOAD
##

I expect a filename wrapped in double-quotes after `Load`.
For example:
> Load "my_file".

command_parser: VERNAC_VARIANT_S
##
## Ends in an error in state: 0.
##
## command_parser' -> . command_parser [ # ]
##
## The known suffix of the stack is as follows:
##
##

I'm currently parsing a program.
At the top level, a command is expected.
For example:
> Eval let f : ?0 := Type in f.
> Check (fun (x : Type) => x).

command_parser: VERNAC_CHECK ID VERNAC_SEPARATOR VERNAC_VARIANT_S
##
## Ends in an error in state: 106.
##
## command_parser -> sequenced_command . EOF [ # ]
##
## The known suffix of the stack is as follows:
## sequenced_command
##

I'm currently parsing a single command.
After `$0`, the end of file is expected.

flag_parser: VERNAC_FLAG_VARIANT VERNAC_SET
##
## Ends in an error in state: 2.
##
## flag -> VERNAC_FLAG_VARIANT . variant [ VERNAC_SEPARATOR EOF ]
##
## The known suffix of the stack is as follows:
## VERNAC_FLAG_VARIANT
##

A variant (G, N or S) must follow the keyword `$0`.
For example:
> $0 G
> $0 N
> $0 S

flag_parser: VERNAC_FLAG_FUEL VERNAC_VARIANT_S
##
## Ends in an error in state: 7.
##
## flag -> VERNAC_FLAG_FUEL . INT [ VERNAC_SEPARATOR EOF ]
##
## The known suffix of the stack is as follows:
## VERNAC_FLAG_FUEL
##

A non-negative integer must follow the keyword `$0`.
Use `0` to allow programs to diverge.
For example:
> $0 0
> $0 10000

command_parser: VERNAC_SET VERNAC_FLAG_FUEL INT VERNAC_VARIANT_S
##
## Ends in an error in state: 109.
##
## sequenced_command -> command . VERNAC_SEPARATOR [ VERNAC_SET VERNAC_LOAD VERNAC_INDUCTIVE VERNAC_EVAL VERNAC_ELABORATE VERNAC_DEFINITION VERNAC_CHECK EOF ]
##
## The known suffix of the stack is as follows:
## command
##

Missing a `.` after $0, to close the command. 
For example:
> $0.

flag_parser: VERNAC_VARIANT_S
##
## Ends in an error in state: 115.
##
## flag_parser' -> . flag_parser [ # ]
##
## The known suffix of the stack is as follows:
##
##

A flag is expected.
For example:
> Fuel 1000
> Variant G

flag_parser: VERNAC_FLAG_FUEL INT VERNAC_VARIANT_S
##
## Ends in an error in state: 117.
##
## flag_parser -> flag . EOF [ # ]
##
## The known suffix of the stack is as follows:
## flag
##

I'm currently parsing a single flag.
After `$0`, the end of file is expected.

command_parser: VERNAC_INDUCTIVE VERNAC_VARIANT_S
##
## Ends in an error in state: 12.
##
## command -> VERNAC_INDUCTIVE . id list(arg) COLON term ASSIGN list(ctor_decl) [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_INDUCTIVE
##

An identifier must come after `$0`.
For example:
> $0 my_inductive_name (x : Type) : Type@1 := <ctor-declarations>.

command_parser: VERNAC_INDUCTIVE ID VERNAC_VARIANT_S
##
## Ends in an error in state: 14.
##
## command -> VERNAC_INDUCTIVE id . list(arg) COLON term ASSIGN list(ctor_decl) [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_INDUCTIVE id
##

I expect arguments of the form `(id ... id : type)` or a `:` (colon) followed
by the sort of the inductive.
For example:
> $1 $0 (a b : Type) : Type@1 := <ctor-declarations>.
> $1 $0 : Type@1 := <ctor-declarations>.

command_parser: VERNAC_INDUCTIVE ID COLON VERNAC_VARIANT_S
##
## Ends in an error in state: 80.
##
## command -> VERNAC_INDUCTIVE id list(arg) COLON . term ASSIGN list(ctor_decl) [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_INDUCTIVE id list(arg) COLON
##

The sort of the inductive declaration must follow the `:` (colon).
For example:
> $3 $2 $1 $0 Type := <ctor-declarations>.

command_parser: VERNAC_INDUCTIVE ID COLON ID VERNAC_VARIANT_S
##
## Ends in an error in state: 81.
##
## command -> VERNAC_INDUCTIVE id list(arg) COLON term . ASSIGN list(ctor_decl) [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_INDUCTIVE id list(arg) COLON term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
##

I expect an `:=` (assign) followed by the body of the definition.
For example:
> $4 $3 $2 $1 $0 := <ctor-declarations>.


ctor_decl_parser: VBAR VERNAC_VARIANT_S
##
## Ends in an error in state: 83.
##
## ctor_decl -> VBAR . id list(arg) COLON term [ VERNAC_SEPARATOR VBAR EOF ]
##
## The known suffix of the stack is as follows:
## VBAR
##

An identifier must come after `$0`.
For example:
> $0 my_constructor_name (x : Type) ...

ctor_decl_parser: VBAR ID VERNAC_VARIANT_S
##
## Ends in an error in state: 84.
##
## ctor_decl -> VBAR id . list(arg) COLON term [ VERNAC_SEPARATOR VBAR EOF ]
##
## The known suffix of the stack is as follows:
## VBAR id
##

I expect arguments of the form `(id ... id : type)` or a `:` (colon) followed
by the type of the constructor.
For example:
> $1 $0 (a b : Type) : <type>
> $1 $0 : <type>

ctor_decl_parser: VBAR ID COLON VERNAC_VARIANT_S
##
## Ends in an error in state: 86.
##
## ctor_decl -> VBAR id list(arg) COLON . term [ VERNAC_SEPARATOR VBAR EOF ]
##
## The known suffix of the stack is as follows:
## VBAR id list(arg) COLON
##

The type of the constructor must follow the `:` (colon).
For example:
> $3 $2 $1 $0 <type>


ctor_decl_parser: VERNAC_VARIANT_S
##
## Ends in an error in state: 111.
##
## ctor_decl_parser' -> . ctor_decl_parser [ # ]
##
## The known suffix of the stack is as follows:
##
##

I expect a constructor declaration starting with `|`.

ctor_decl_parser: VBAR ID COLON ID VERNAC_VARIANT_S
##
## Ends in an error in state: 113.
##
## ctor_decl_parser -> ctor_decl . EOF [ # ]
##
## The known suffix of the stack is as follows:
## ctor_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 87, spurious reduction of production ctor_decl -> VBAR id list(arg) COLON term
##

I'm currently parsing a single constructor declaration.
After `$0`, the end of file is expected.

term_parser: KWD_UNIVERSE VERNAC_VARIANT_S
##
## Ends in an error in state: 23.
##
## atom -> KWD_UNIVERSE . AT INT [ VERNAC_SEPARATOR VBAR RPAREN LPAREN KWD_WITH KWD_UNKNOWN_T KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_END KWD_AS ID EOF COLON ASSIGN ARROW ]
## atom -> KWD_UNIVERSE . [ VERNAC_SEPARATOR VBAR RPAREN LPAREN KWD_WITH KWD_UNKNOWN_T KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_END KWD_AS ID EOF COLON ASSIGN ARROW ]
##
## The known suffix of the stack is as follows:
## KWD_UNIVERSE
##

I'm currently parsing a universe.
For example:
> $0
> $0 @ 1

term_parser: KWD_UNIVERSE AT VERNAC_VARIANT_S
##
## Ends in an error in state: 24.
##
## atom -> KWD_UNIVERSE AT . INT [ VERNAC_SEPARATOR VBAR RPAREN LPAREN KWD_WITH KWD_UNKNOWN_T KWD_UNKNOWN KWD_UNIVERSE KWD_IN KWD_END KWD_AS ID EOF COLON ASSIGN ARROW ]
##
## The known suffix of the stack is as follows:
## KWD_UNIVERSE AT
##

I'm currently parsing the level of a universe.
After the `$0`, a non-negative integer is expected.
For example:
> $1 $0 1

term_parser: KWD_MATCH VERNAC_VARIANT_S
##
## Ends in an error in state: 26.
##
## term -> KWD_MATCH . AT id top KWD_AS id KWD_RETURN top KWD_WITH list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT VERNAC_VARIANT_S
##
## Ends in an error in state: 27.
##
## term -> KWD_MATCH AT . id top KWD_AS id KWD_RETURN top KWD_WITH list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH AT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID VERNAC_VARIANT_S
##
## Ends in an error in state: 28.
##
## term -> KWD_MATCH AT id . top KWD_AS id KWD_RETURN top KWD_WITH list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH AT id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID VERNAC_SEPARATOR
##
## Ends in an error in state: 53.
##
## term -> KWD_MATCH AT id top . KWD_AS id KWD_RETURN top KWD_WITH list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
## top -> top . COLON term [ KWD_AS COLON ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH AT id top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS VERNAC_VARIANT_S
##
## Ends in an error in state: 54.
##
## term -> KWD_MATCH AT id top KWD_AS . id KWD_RETURN top KWD_WITH list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH AT id top KWD_AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID VERNAC_VARIANT_S
##
## Ends in an error in state: 55.
##
## term -> KWD_MATCH AT id top KWD_AS id . KWD_RETURN top KWD_WITH list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH AT id top KWD_AS id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID KWD_RETURN VERNAC_VARIANT_S
##
## Ends in an error in state: 56.
##
## term -> KWD_MATCH AT id top KWD_AS id KWD_RETURN . top KWD_WITH list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH AT id top KWD_AS id KWD_RETURN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID KWD_RETURN ID VERNAC_SEPARATOR
##
## Ends in an error in state: 57.
##
## term -> KWD_MATCH AT id top KWD_AS id KWD_RETURN top . KWD_WITH list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
## top -> top . COLON term [ KWD_WITH COLON ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH AT id top KWD_AS id KWD_RETURN top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID KWD_RETURN ID KWD_WITH VERNAC_VARIANT_S
##
## Ends in an error in state: 58.
##
## term -> KWD_MATCH AT id top KWD_AS id KWD_RETURN top KWD_WITH . list(branch_decl) KWD_END [ VERNAC_SEPARATOR VBAR RPAREN KWD_WITH KWD_IN KWD_END KWD_AS EOF COLON ASSIGN ]
##
## The known suffix of the stack is as follows:
## KWD_MATCH AT id top KWD_AS id KWD_RETURN top KWD_WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID KWD_RETURN ID KWD_WITH VBAR VERNAC_VARIANT_S
##
## Ends in an error in state: 59.
##
## branch_decl -> VBAR . id list(id) BIG_ARROW top [ VBAR KWD_END ]
##
## The known suffix of the stack is as follows:
## VBAR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID KWD_RETURN ID KWD_WITH VBAR ID VERNAC_VARIANT_S
##
## Ends in an error in state: 60.
##
## branch_decl -> VBAR id . list(id) BIG_ARROW top [ VBAR KWD_END ]
##
## The known suffix of the stack is as follows:
## VBAR id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID KWD_RETURN ID KWD_WITH VBAR ID BIG_ARROW VERNAC_VARIANT_S
##
## Ends in an error in state: 62.
##
## branch_decl -> VBAR id list(id) BIG_ARROW . top [ VBAR KWD_END ]
##
## The known suffix of the stack is as follows:
## VBAR id list(id) BIG_ARROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID KWD_RETURN ID KWD_WITH VBAR ID BIG_ARROW ID VERNAC_SEPARATOR
##
## Ends in an error in state: 63.
##
## branch_decl -> VBAR id list(id) BIG_ARROW top . [ VBAR KWD_END ]
## top -> top . COLON term [ VBAR KWD_END COLON ]
##
## The known suffix of the stack is as follows:
## VBAR id list(id) BIG_ARROW top
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 66, spurious reduction of production top -> term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

term_parser: KWD_MATCH AT ID ID KWD_AS ID KWD_RETURN ID KWD_WITH VBAR ID ID VERNAC_VARIANT_S
##
## Ends in an error in state: 67.
##
## list(id) -> id . list(id) [ BIG_ARROW ]
##
## The known suffix of the stack is as follows:
## id
##

<YOUR SYNTAX ERROR MESSAGE HERE>

command_parser: VERNAC_INDUCTIVE ID COLON ID ASSIGN VERNAC_VARIANT_S
##
## Ends in an error in state: 82.
##
## command -> VERNAC_INDUCTIVE id list(arg) COLON term ASSIGN . list(ctor_decl) [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## VERNAC_INDUCTIVE id list(arg) COLON term ASSIGN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

command_parser: VERNAC_INDUCTIVE ID COLON ID ASSIGN VBAR ID COLON ID RPAREN
##
## Ends in an error in state: 91.
##
## list(ctor_decl) -> ctor_decl . list(ctor_decl) [ VERNAC_SEPARATOR ]
##
## The known suffix of the stack is as follows:
## ctor_decl
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 40, spurious reduction of production term -> fact
## In state 87, spurious reduction of production ctor_decl -> VBAR id list(arg) COLON term
##

<YOUR SYNTAX ERROR MESSAGE HERE>
