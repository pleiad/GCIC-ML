Inductive bool : Type :=
| false : bool 
| true : bool.

Definition rec2 (c : bool -> Type@1) (fb : c false) (tb : c true) (b : bool) : c b :=
match@bool b as z return c z with 
| false => fb 
| true => tb 
end.

Inductive void : Type :=.

Definition rec0 (c : Type@1) (f : void) : c := ?0.

Inductive unit : Type := | tt : unit.

Inductive list (a : Type) : Type :=
| nil : list a 
| cons (hd : a) (tl : list a) : list a.

Inductive W (a : Type) (b : a -> Type) : Type@1 :=
| sup (x : a) (f : b x -> W a b) : W a b.


Definition natarity : bool -> Type := rec2 (fun (b : bool) => Type) void unit.

Definition natW : Type@1 := W bool natarity.

Definition zero : natW := sup bool natarity false (fun (x : void) => rec0 natW x).

Definition one : natW := sup bool natarity true (fun (x : unit) => zero).

Definition succ (n : natW) : natW := sup bool natarity true (fun (x : unit) => n).

Inductive sum (a b : Type): Type :=
| inl (x : a) : sum a b 
| inr (x : b) : sum a b.

Definition recsum (c a b : Type) (l : a -> c) (r : b -> c) (s : sum a b) : c :=
match@sum s as z return c with 
| inl a b x => l x 
| inr a b x => r x 
end.

Fixpoint recW (A : Type) (B : A -> Type) (E : W A B -> Type@1) 
  (e : forall (x : A) (f : B x -> W A B) (rec : forall (b : B x), E (f b)), E (sup A B x f))
  (w : W A B) {struct w} : E w :=
match@W w as z return E z with
| sup A B a f => e a f (fun (b : B a) => recW A B E e (f b))
end.

Definition recnatW (C : natW -> Type@1) 
  (e : forall (x : bool) (f : natarity x -> W bool natarity) (rec : forall (b : natarity x), C (f b)), C (sup bool natarity x f))
  (n : W bool natarity) : C n := recW bool natarity C e n.

Definition double : natW -> natW :=
recnatW (fun (x : natW) => natW) 
  (rec2 (fun (b : bool ) =>
    forall (f : natarity b -> natW)
          (g : natarity b -> natW),
          W bool natarity)
        (fun (f : void -> natW)
            (g : void -> natW) =>
            zero)
        (fun (f : unit -> natW)
            (g : unit -> natW) =>
            succ (succ (g tt)))).
